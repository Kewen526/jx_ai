# -*- coding: utf-8 -*-
"""
AIËØÑËÆ∫ÂõûÂ§çÁîüÊàêÂô®
- ‰ªéMySQLÊï∞ÊçÆÂ∫ìËØªÂèñÊú™ÂõûÂ§çÁöÑÁæéÂõ¢/Â§ß‰ºóÁÇπËØÑËØÑËÆ∫
- Ë∞ÉÁî®Êô∫Ë∞±AIÁîüÊàêÂïÜÂÆ∂ÂõûÂ§ç
- Â∞ÜÁîüÊàêÁöÑÂõûÂ§çÂÜôÂõûÊï∞ÊçÆÂ∫ì
"""

import asyncio
import aiomysql
import aiohttp
import time
import threading
import logging
from typing import Optional, List, Dict, Any
from functools import wraps
from dataclasses import dataclass

# ============================================================
# Ëá™ÂÆö‰πâÂºÇÂ∏∏
# ============================================================
class ContentFilterError(Exception):
    """ÊïèÊÑüËØçËøáÊª§ÂºÇÂ∏∏ - ‰∏çÈúÄË¶ÅÈáçËØï"""
    pass

# ============================================================
# Êó•ÂøóÈÖçÁΩÆ
# ============================================================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ============================================================
# Êï∞ÊçÆÂ∫ìÈÖçÁΩÆ
# ============================================================
DB_CONFIG = {
    "host": "8.146.210.145",
    "port": 3306,
    "user": "root",
    "password": "Kewen888@",
    "db": "jx_data_info",
    "charset": "utf8mb4",
    "autocommit": True
}

# Ë°®ÈÖçÁΩÆ
TABLES = {
    "meituan": {
        "name": "review_detail_meituan",
        "has_product": True
    },
    "dianping": {
        "name": "review_detail_dianping",
        "has_product": False
    }
}

# ============================================================
# APIÈÖçÁΩÆ
# ============================================================
ZHIPUAI_API_KEYS = [
    "f31eaff26ee04560836b1d3ab92eacc8.oyPI18DOuSKebrna",
    "69344382e19945a497697230f161c183.RAyvPnxU5docbnN7",
    "fa5a8e68c93e405fa402df81124af0f9.64aRePpnl0sAjJsq",
    "3f3b09e8aa524b069cdd2a589a76a261.OoeZfL1pzAWrKBEI",
    "65f085e030e446309959fcdbdf7bb528.9TpxtScWIEiDXgVp",
    "37a96354b4364d1199cd530198cd1506.SqjVbJcRyU2b31vE",
    "131a657523954446932045ed7e3cebc2.tsiLEwwbw2TC4ImB",
    "81b0ed0f1db74f278b7b7ccf7b77027c.8C18IDpwc0CkJJBO",
]

# Âπ∂ÂèëÊéßÂà∂
MAX_CONCURRENT = 3  # ÊúÄÂ§ßÂπ∂ÂèëÊï∞


# ============================================================
# Êï∞ÊçÆÊ®°Âûã
# ============================================================
@dataclass
class ReviewTask:
    """ËØÑËÆ∫‰ªªÂä°"""
    table_name: str
    id: int
    shop_id: str
    shop_name: str
    star: int
    content: str
    product_name: str


# ============================================================
# APIÂØÜÈí•ÁÆ°ÁêÜÂô®
# ============================================================
class APIKeyManager:
    """APIÂØÜÈí•ÁÆ°ÁêÜÂô® - Â§ÑÁêÜÈªëÂêçÂçïÂíåËΩÆÊç¢"""

    def __init__(self, blacklist_duration: int = 180):
        self.blacklist_duration = blacklist_duration
        self.blacklisted_keys = {}
        self.last_used_index = -1
        self.lock = threading.RLock()

    def add_to_blacklist(self, api_key: str, reason: str = "ÈôêÊµÅ"):
        with self.lock:
            end_time = time.time() + self.blacklist_duration
            self.blacklisted_keys[api_key] = end_time
            logger.warning(f"‚ö†Ô∏è ÂØÜÈí•Âä†ÂÖ•ÈªëÂêçÂçï({reason}): ...{api_key[-8:]} ({self.blacklist_duration}Áßí)")

    def is_blacklisted(self, api_key: str) -> bool:
        with self.lock:
            if api_key not in self.blacklisted_keys:
                return False
            current_time = time.time()
            if current_time >= self.blacklisted_keys[api_key]:
                del self.blacklisted_keys[api_key]
                logger.info(f"‚úÖ ÂØÜÈí•ÈªëÂêçÂçïËøáÊúüÊÅ¢Â§ç: ...{api_key[-8:]}")
                return False
            return True

    def get_next_available_key(self, all_keys: List[str]) -> Optional[str]:
        with self.lock:
            if not all_keys:
                return None
            self._cleanup_expired()
            available_keys = [key for key in all_keys if not self.is_blacklisted(key)]
            if not available_keys:
                logger.error(f"‚ùå ÊâÄÊúâ {len(all_keys)} ‰∏™ÂØÜÈí•ÈÉΩÂú®ÈªëÂêçÂçï‰∏≠")
                return None
            self.last_used_index = (self.last_used_index + 1) % len(available_keys)
            selected_key = available_keys[self.last_used_index]
            return selected_key

    def _cleanup_expired(self):
        current_time = time.time()
        expired = [k for k, t in self.blacklisted_keys.items() if current_time >= t]
        for key in expired:
            del self.blacklisted_keys[key]

    def record_success(self, api_key: str):
        pass  # ÈùôÈªòÊàêÂäü

    def record_failure(self, api_key: str, error_msg: str):
        error_lower = error_msg.lower()
        is_rate_limit = any(keyword in error_lower for keyword in [
            'rate limit', 'too many requests', '429', 'quota exceeded',
            '1302', 'Âπ∂ÂèëÊï∞ËøáÈ´ò', 'concurrent', 'ÈôêÊµÅ', 'ËØ∑Ê±ÇËøá‰∫éÈ¢ëÁπÅ'
        ])
        if is_rate_limit:
            self.add_to_blacklist(api_key, "ÈôêÊµÅ")
        else:
            logger.warning(f"‚ö†Ô∏è ÂØÜÈí•Ë∞ÉÁî®Â§±Ë¥•: ...{api_key[-8:]}, ÈîôËØØ: {error_msg[:100]}")


# ÂÖ®Â±ÄÂØÜÈí•ÁÆ°ÁêÜÂô®
key_manager = APIKeyManager(blacklist_duration=180)


# ============================================================
# ÊåáÊï∞ÈÄÄÈÅøÈáçËØïË£ÖÈ•∞Âô®
# ============================================================
def exponential_backoff_retry(max_retries: int = 10, base_wait: float = 2, max_wait: float = 60):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    result = await func(*args, **kwargs)
                    if isinstance(result, str) and 'Â§±Ë¥•' in result:
                        raise Exception(f"ËøîÂõûÂ§±Ë¥•ÁªìÊûú: {result}")
                    return result
                except ContentFilterError:
                    # ÊïèÊÑüËØçÈîôËØØ‰∏çÈáçËØïÔºåÁõ¥Êé•ÊäõÂá∫
                    raise
                except Exception as e:
                    attempt_num = attempt + 1
                    logger.error(f"‚ùå Á¨¨{attempt_num}/{max_retries}Ê¨°Â∞ùËØïÂ§±Ë¥•: {str(e)[:200]}")
                    if attempt == max_retries - 1:
                        raise Exception(f"ÈáçËØï{max_retries}Ê¨°Âêé‰ªçÂ§±Ë¥•: {str(e)}")
                    wait_time = min(base_wait * (2 ** attempt), max_wait)
                    logger.warning(f"‚è≥ Á≠âÂæÖ{wait_time}ÁßíÂêéËøõË°åÁ¨¨{attempt_num + 1}Ê¨°ÈáçËØï...")
                    await asyncio.sleep(wait_time)
            raise Exception(f"ÈáçËØï{max_retries}Ê¨°Âêé‰ªçÂ§±Ë¥•")
        return wrapper
    return decorator


# ============================================================
# SessionÁÆ°ÁêÜÂô®
# ============================================================
class SessionManager:
    def __init__(self):
        self._session = None
        self._lock = asyncio.Lock()

    async def get_session(self) -> aiohttp.ClientSession:
        async with self._lock:
            if self._session is None or self._session.closed:
                timeout = aiohttp.ClientTimeout(total=120, connect=15)
                connector = aiohttp.TCPConnector(limit=20, limit_per_host=10)
                self._session = aiohttp.ClientSession(connector=connector, timeout=timeout)
            return self._session

    async def close(self):
        async with self._lock:
            if self._session and not self._session.closed:
                await self._session.close()


# ============================================================
# ÊèêÁ§∫ËØçÊ®°Êùø
# ============================================================
SYSTEM_PROMPT = "‰Ω†ÊòØ‰∏Ä‰Ωç‰∏ì‰∏öÁöÑÁæéÂõ¢/Â§ß‰ºóÁÇπËØÑÂïÜÂÆ∂ËØÑËÆ∫ÂõûÂ§çÂä©ÊâãÔºåË¥üË¥£‰∏∫SPA/Ë∂≥ÈÅì/ÂÖªÁîüÂ∫óÈì∫ÁîüÊàêÊ∏©È¶®„ÄÅ‰∏ì‰∏öÁöÑÂÆ¢Êà∑ËØÑËÆ∫ÂõûÂ§ç"

PROMPT_TEMPLATE = """
‰Ω†ÊòØ‰∏Ä‰Ωç‰∏ì‰∏öÁöÑÂïÜÂÆ∂ËØÑËÆ∫ÂõûÂ§çÂä©ÊâãÔºåË¥üË¥£‰∏∫SPA/Ë∂≥ÈÅì/ÂÖªÁîüÂ∫óÈì∫ÁîüÊàêÊ∏©È¶®„ÄÅ‰∏ì‰∏öÁöÑÂÆ¢Êà∑ËØÑËÆ∫ÂõûÂ§ç„ÄÇ

## ËæìÂÖ•‰ø°ÊÅØ
- Â∫óÈì∫ÂêçÁß∞Ôºö{shop_name}
- ËØÑËÆ∫ÊòüÁ∫ßÔºö{star}Ôºà1-5ÂàÜÔºå1-3‰∏∫‰∏≠Â∑ÆËØÑÔºå4-5‰∏∫Â•ΩËØÑÔºâ
- ÂÆ¢Êà∑ËØÑËÆ∫ÂÜÖÂÆπÔºö{content}ÔºàÂèØËÉΩ‰∏∫"Êó†"Ë°®Á§∫ÂÆ¢Êà∑Êú™ÂÜôËØÑËÆ∫ÊñáÂ≠óÔºâ
- ÂÆ¢Êà∑Ë¥≠‰π∞ÁöÑÂõ¢Ë¥≠Ôºö{product_name}ÔºàÂèØËÉΩ‰∏∫"Êó†"Ë°®Á§∫Êú™Ë¥≠‰π∞Âõ¢Ë¥≠Ôºâ

## Ê†∏ÂøÉÂéüÂàôÔºöÂè™ÂõûÂ∫îÂÆ¢Êà∑ÂÆûÈôÖÊèêÂà∞ÁöÑÂÜÖÂÆπ

**‰Ω†ÂøÖÈ°ª‰∏•Ê†ºÂü∫‰∫éÂÆ¢Êà∑ËØÑËÆ∫‰∏≠ÊòéÁ°ÆÊèêÂà∞ÁöÑ‰ø°ÊÅØËøõË°åÂõûÂ§çÔºåÁªù‰∏çËôöÊûÑÊàñË°•ÂÖÖ‰ªª‰ΩïÂÜÖÂÆπ„ÄÇ**

## Á¶ÅÊ≠¢‰∫ãÈ°πÔºàÂøÖÈ°ªÈÅµÂÆàÔºâ

1. **Á¶ÅÊ≠¢ËôöÊûÑÊäÄÂ∏à**ÔºöÈô§ÈùûÂÆ¢Êà∑ËØÑËÆ∫‰∏≠ÊòéÁ°ÆÂÜôÂá∫‰∫ÜÊäÄÂ∏àÁºñÂè∑ÔºåÂê¶ÂàôÁªùÂØπ‰∏çËÉΩÂú®ÂõûÂ§ç‰∏≠ÊèêÂèä‰ªª‰ΩïÊäÄÂ∏àÁºñÂè∑
2. **Á¶ÅÊ≠¢Âç†‰ΩçÁ¨¶**ÔºöÂõûÂ§ç‰∏≠‰∏çÂæóÂá∫Áé∞"XX"„ÄÅ"ÊüêÊüê"„ÄÅ"[È°πÁõÆÂêç]"„ÄÅ"{{{{xxx}}}}"Á≠â‰ªª‰ΩïÂç†‰ΩçÁ¨¶ÊàñÂèòÈáèÁ¨¶Âè∑
3. **Á¶ÅÊ≠¢Âá≠Á©∫Êé®Ëçê**ÔºöÂ¶ÇÊûúÊ≤°ÊúâÂÖ∑‰ΩìÈ°πÁõÆÂèØÊé®ËçêÔºå‰∏çË¶Å‰ΩøÁî®"Ê¨¢ËøéÂ∞ùËØïÊàë‰ª¨ÁöÑÂÖ∂‰ªñÈ°πÁõÆ"Á≠âÁ©∫Ê≥õËØùÊúØ
4. **Á¶ÅÊ≠¢Êù°‰ª∂Âè•Â§ñÈú≤**Ôºö‰∏çÂæóÂá∫Áé∞"Â¶ÇÊûúÊÇ®ÊèêÂà∞ÁöÑ..."„ÄÅ"Â¶ÇÊûúÊÇ®‰∏ãÊ¨°..."Á≠âÊù°‰ª∂ÂºïÂØºÂè•Âºè

## ÂõûÂ§çËßÑÂàô

### 1. Ê†πÊçÆÊòüÁ∫ßË∞ÉÊï¥ËØ≠Ê∞î
- **Â•ΩËØÑÔºà4-5ÂàÜÔºâ**ÔºöÁÉ≠ÊÉÖÊÑüË∞¢ÔºåË°®ËææÊ¨£ÂñúÔºåËÇØÂÆöÂÆ¢Êà∑ÁöÑÈÄâÊã©
- **‰∏≠Â∑ÆËØÑÔºà1-3ÂàÜÔºâ**ÔºöÁúüËØöËá¥Ê≠âÔºåË°®ËææÈáçËßÜÔºåÊâøËØ∫ÊîπËøõ

### 2. Ê†πÊçÆËØÑËÆ∫ÂÜÖÂÆπ‰∏™ÊÄßÂåñÂõûÂ§çÔºà‰∏•Ê†ºÈÅµÂæ™"ÊúâÂàôÂõûÂ∫îÔºåÊó†ÂàôË∑≥Ëøá"ÂéüÂàôÔºâ

| ÂÆ¢Êà∑ËØÑËÆ∫‰∏≠ÂåÖÂê´ | ÂõûÂ§ç‰∏≠ÁöÑÂ§ÑÁêÜÊñπÂºè |
|---------------|-----------------|
| ÊòéÁ°ÆÁöÑÊäÄÂ∏àÁºñÂè∑ | ÊèêÂèäËØ•ÊäÄÂ∏àÂπ∂Áªô‰∫àËÇØÂÆö |
| Êú™ÊèêÂèäÊäÄÂ∏à | **ÂÆåÂÖ®‰∏çÊèêÊäÄÂ∏àÔºåË∑≥ËøáÊ≠§È°π** |
| ÂÖ∑‰Ωì‰ΩìÈ™åÊèèËø∞ÔºàÂ¶ÇÊâãÊ≥ï„ÄÅÁéØÂ¢ÉÔºâ | ÂõûÂ∫îÂπ∂ËÇØÂÆöËøô‰∫õÂÜÖÂÆπ |
| ËØÑËÆ∫‰∏∫"Êó†"ÊàñÊó†ÂÖ∑‰ΩìÂÜÖÂÆπ | ‰ΩøÁî®ÈÄöÁî®ÊÑüË∞¢ËØùÊúØÔºå‰∏çË¶ÅÁºñÈÄ†ÁªÜËäÇ |

### 3. Ê†πÊçÆÂõ¢Ë¥≠ÊÉÖÂÜµË∞ÉÊï¥

| Âõ¢Ë¥≠ÊÉÖÂÜµ | ÂõûÂ§çÂ§ÑÁêÜ |
|---------|---------|
| ÊúâÂÖ∑‰ΩìÂõ¢Ë¥≠ÂêçÁß∞ | ÂèØÊèêÂèä"ÊÑüË∞¢ÊÇ®‰ΩìÈ™åÊàë‰ª¨ÁöÑ{product_name}" |
| Âõ¢Ë¥≠‰∏∫"Êó†" | **‰∏çÊèê‰ªª‰ΩïÈ°πÁõÆÂêçÁß∞Ôºå‰∏çÊé®Ëçê‰ªª‰ΩïÈ°πÁõÆ** |

### 4. ÂõûÂ§çÁªìÊûÑ

**Â•ΩËØÑÂõûÂ§çÔºàÊ†πÊçÆÂÆûÈôÖÊÉÖÂÜµÈÄâÁî®ÔºåÁº∫Â§±‰ø°ÊÅØÁöÑÈÉ®ÂàÜÁõ¥Êé•Ë∑≥ËøáÔºâÔºö**
1. Áß∞Âëº + ÊÑüË∞¢ËØ≠
2. „Äê‰ªÖÂΩìÂÆ¢Êà∑ÊèêÂà∞ÂÖ∑‰ΩìÂÜÖÂÆπÊó∂„ÄëÂõûÂ∫îËØÑËÆ∫‰∏≠ÁöÑÂÖ∑‰Ωì‰ΩìÈ™å
3. „Äê‰ªÖÂΩìÂÆ¢Êà∑ÊèêÂà∞ÊäÄÂ∏àÊó∂„ÄëËÇØÂÆöËØ•ÊäÄÂ∏àÁöÑÊúçÂä°
4. Â∫óÈì∫ÁöÑÊúçÂä°ÊâøËØ∫
5. ÊúüÂæÖÂÜçÊ¨°ÂÖâ‰∏¥ÁöÑÁ•ùÁ¶èËØ≠

**‰∏≠Â∑ÆËØÑÂõûÂ§çÔºö**
1. Áß∞Âëº + ÁúüËØöËá¥Ê≠â
2. Ë°®ËææÂØπÂÆ¢Êà∑ÂèçÈ¶àÁöÑÈáçËßÜ
3. ÊâøËØ∫ÊîπËøõÁöÑÂÖ∑‰ΩìÊÄÅÂ∫¶
4. ÊÑüË∞¢ÂèçÈ¶à + ÊúüÂæÖÁªô‰∫àÂÜçÊ¨°Êú∫‰ºö

### 5. ËØ≠Ë®ÄÈ£éÊ†º
- ‰∫≤ÂàáÊ∏©ÊöñÔºåËá™ÁÑ∂ÊµÅÁïÖ
- Áß∞ÂëºÂèØÁî®Ôºö‰∫≤Áà±ÁöÑÈ°æÂÆ¢„ÄÅÂ∞äÊï¨ÁöÑÂÆ¢ÂÆò
- ÂõûÂ§çÈïøÂ∫¶Ôºö80-150Â≠ó
- ÈÅøÂÖçÊ®°ÊùøÊÑüÂíåÂÆòÊñπËÖîË∞É

## ËæìÂá∫ÂâçËá™Ê£ÄÔºàÂøÖÈ°ªÊâßË°åÔºâ

ÁîüÊàêÂõûÂ§çÂêéÔºåÊ£ÄÊü•‰ª•‰∏ãÈ°πÁõÆÔºö
- [ ] ÊòØÂê¶ÂåÖÂê´"XX"„ÄÅ"ÊüêÊüê"„ÄÅÊñπÊã¨Âè∑„ÄÅËä±Êã¨Âè∑Ôºü‚Üí ÊúâÂàôÂà†Èô§Êï¥Âè•
- [ ] ÊòØÂê¶ÊèêÂà∞‰∫ÜÂÆ¢Êà∑Ê≤°ÊúâÊèêÂà∞ÁöÑÊäÄÂ∏àÁºñÂè∑Ôºü‚Üí ÊúâÂàôÂà†Èô§Êï¥Âè•
- [ ] ÊòØÂê¶Êé®Ëçê‰∫Ü‰∏çÂ≠òÂú®ÁöÑÈ°πÁõÆÔºü‚Üí ÊúâÂàôÂà†Èô§Êï¥Âè•
- [ ] ÊòØÂê¶Âá∫Áé∞"Â¶ÇÊûúÊÇ®..."ÁöÑÊù°‰ª∂Âè•Ôºü‚Üí ÊúâÂàôÊîπÂÜôÊàñÂà†Èô§

## ÈîôËØØÁ§∫‰æãÔºàÁªùÂØπÈÅøÂÖçÔºâ

‚ùå "ÊÑüË∞¢ÊÇ®ÂØπ11Âè∑ÊäÄÂ∏àÁöÑËÆ§ÂèØ"ÔºàÂÆ¢Êà∑Êú™ÊèêÂà∞11Âè∑Ôºâ
‚ùå "Ê¨¢Ëøé‰∏ãÊ¨°‰ΩìÈ™åÊàë‰ª¨ÁöÑ[XXÈ°πÁõÆ]"ÔºàÂç†‰ΩçÁ¨¶Â§ñÈú≤Ôºâ
‚ùå "Â¶ÇÊûúÊÇ®ÊèêÂà∞ÁöÑÊäÄÂ∏àÔºåÊàë‰ª¨‰ºöËΩ¨ËææÊÇ®ÁöÑËÇØÂÆö"ÔºàÊù°‰ª∂Âè•Â§ñÈú≤Ôºâ
‚ùå "ÊúüÂæÖÊÇ®Â∞ùËØïÊàë‰ª¨ÁöÑÂÖ∂‰ªñÁâπËâ≤È°πÁõÆÔºåÂ¶ÇXXÊåâÊë©"ÔºàÂá≠Á©∫Êé®ËçêÔºâ

## Ê≠£Á°ÆÁ§∫‰æã

**Á§∫‰æã1ÔºöÂÆ¢Êà∑Â•ΩËØÑ‰∏îÊèêÂà∞ÊäÄÂ∏à**
ËæìÂÖ•ÔºöÊòüÁ∫ß5ÂàÜÔºåËØÑËÆ∫"ÁéØÂ¢ÉÂæàÂ•ΩÔºå8Âè∑ÊäÄÂ∏àÊâãÊ≥ï‰∏ì‰∏ö"ÔºåÂõ¢Ë¥≠"ÂÖ®Ë∫´Á≤æÊ≤πSPA"
ËæìÂá∫Ôºö‰∫≤Áà±ÁöÑÈ°æÂÆ¢ÔºåÈùûÂ∏∏ÊÑüË∞¢ÊÇ®ÁöÑ‰∫îÊòüÂ•ΩËØÑÔºÅÂæàÈ´òÂÖ¥Êàë‰ª¨ÁöÑÁéØÂ¢ÉÂíå8Âè∑ÊäÄÂ∏àÁöÑ‰∏ì‰∏öÊâãÊ≥ïÈÉΩÂæóÂà∞‰∫ÜÊÇ®ÁöÑËÆ§ÂèØ„ÄÇÊÑüË∞¢ÊÇ®‰ΩìÈ™åÊàë‰ª¨ÁöÑÂÖ®Ë∫´Á≤æÊ≤πSPAÔºåÊÇ®ÁöÑÊª°ÊÑèÊòØÊàë‰ª¨ÊúÄÂ§ßÁöÑÂä®Âäõ„ÄÇÊàë‰ª¨‰ºöÁªßÁª≠‰øùÊåÅÈ´òÂìÅË¥®ÊúçÂä°ÔºåÊúüÂæÖÊÇ®ÁöÑÂÜçÊ¨°ÂÖâ‰∏¥ÔºåÁ•ùÊÇ®ÁîüÊ¥ªÊÑâÂø´ÔºÅ

**Á§∫‰æã2ÔºöÂÆ¢Êà∑Â•ΩËØÑ‰ΩÜÊó†ÂÖ∑‰ΩìÂÜÖÂÆπ**
ËæìÂÖ•ÔºöÊòüÁ∫ß5ÂàÜÔºåËØÑËÆ∫"Êó†"ÔºåÂõ¢Ë¥≠"Êó†"
ËæìÂá∫Ôºö‰∫≤Áà±ÁöÑÈ°æÂÆ¢ÔºåÈùûÂ∏∏ÊÑüË∞¢ÊÇ®ÁöÑ‰∫îÊòüÂ•ΩËØÑ‰∏éÊîØÊåÅÔºÅÊÇ®ÁöÑËÆ§ÂèØÊòØÊàë‰ª¨ÂâçËøõÁöÑÂä®Âäõ„ÄÇÊàë‰ª¨‰ºöÊåÅÁª≠‰∏∫ÊÇ®Êèê‰æõËàíÈÄÇÁöÑÁéØÂ¢ÉÂíå‰ºòË¥®ÁöÑÊúçÂä°ÔºåÊúüÂæÖÊÇ®ÁöÑÂÜçÊ¨°ÂÖâ‰∏¥ÔºåÁ•ùÊÇ®Ë∫´‰ΩìÂÅ•Â∫∑„ÄÅÁîüÊ¥ªÊÑâÂø´ÔºÅ

**Á§∫‰æã3Ôºö‰∏≠Â∑ÆËØÑ**
ËæìÂÖ•ÔºöÊòüÁ∫ß2ÂàÜÔºåËØÑËÆ∫"Á≠â‰∫ÜÂæà‰πÖ"ÔºåÂõ¢Ë¥≠"Ë∂≥ÁñóÂ•óÈ§ê"
ËæìÂá∫Ôºö‰∫≤Áà±ÁöÑÈ°æÂÆ¢ÔºåÈùûÂ∏∏Êä±Ê≠âÁªôÊÇ®Â∏¶Êù•‰∫Ü‰∏çÂ•ΩÁöÑÁ≠âÂæÖ‰ΩìÈ™åÔºåÊàë‰ª¨Ê∑±Ë°®Ê≠âÊÑè„ÄÇÊÇ®ÁöÑÂèçÈ¶àÊàë‰ª¨ÈùûÂ∏∏ÈáçËßÜÔºåÂ∑≤ÁªèÂú®‰ºòÂåñÈ¢ÑÁ∫¶ÂíåÊéíÈòüÊµÅÁ®ãÔºåÈÅøÂÖçÁ±ª‰ººÊÉÖÂÜµÂÜçÊ¨°ÂèëÁîü„ÄÇÊÑüË∞¢ÊÇ®ÁöÑÂÆùË¥µÊÑèËßÅÔºåÁúüËØöÊúüÂæÖËÉΩÊúâÊú∫‰ºö‰∏∫ÊÇ®Êèê‰æõÊõ¥Â•ΩÁöÑÊúçÂä°‰ΩìÈ™å„ÄÇ

## ËæìÂá∫Ë¶ÅÊ±Ç

Áõ¥Êé•ËæìÂá∫ÂõûÂ§çÂÜÖÂÆπÔºåÊó†ÈúÄ‰ªª‰ΩïËß£ÈáäËØ¥Êòé„ÄÇ
"""


# ============================================================
# AIË∞ÉÁî®ÂáΩÊï∞
# ============================================================
@exponential_backoff_retry(max_retries=10, base_wait=2, max_wait=60)
async def call_zhipuai(
        session_manager: SessionManager,
        prompt: str,
        system_prompt: str = None,
        model: str = "glm-4-flash",
        temperature: float = 0.1,
        max_tokens: int = 4096
) -> str:
    """Ë∞ÉÁî®Êô∫Ë∞±AI"""
    selected_key = key_manager.get_next_available_key(ZHIPUAI_API_KEYS)

    if not selected_key:
        logger.warning("‚ö†Ô∏è ÊâÄÊúâÂØÜÈí•ÈÉΩÂú®ÈªëÂêçÂçï‰∏≠ÔºåÁ≠âÂæÖ30Áßí...")
        await asyncio.sleep(30)
        selected_key = key_manager.get_next_available_key(ZHIPUAI_API_KEYS)
        if not selected_key:
            raise Exception("ÊâÄÊúâÂØÜÈí•ÈÉΩ‰∏çÂèØÁî®")

    try:
        url = "https://open.bigmodel.cn/api/paas/v4/chat/completions"
        headers = {
            "Authorization": f"Bearer {selected_key}",
            "Content-Type": "application/json"
        }

        messages = []
        if system_prompt:
            messages.append({"role": "system", "content": system_prompt})
        messages.append({"role": "user", "content": prompt})

        payload = {
            "model": model,
            "messages": messages,
            "temperature": temperature,
            "max_tokens": max_tokens
        }

        session = await session_manager.get_session()

        async with session.post(url, headers=headers, json=payload, timeout=120) as response:
            if response.status == 200:
                result = await response.json()
                if 'choices' in result and len(result['choices']) > 0:
                    content = result['choices'][0]['message']['content']
                    key_manager.record_success(selected_key)
                    return content
                else:
                    raise Exception(f"ÂìçÂ∫îÊ†ºÂºèÈîôËØØ: {result}")
            else:
                response_text = await response.text()
                key_manager.record_failure(selected_key, f"HTTP {response.status}: {response_text}")
                # Ê£ÄÊµã1301ÊïèÊÑüËØçÈîôËØØ
                if '"code":"1301"' in response_text or '"1301"' in response_text:
                    logger.warning(f"‚ö†Ô∏è Ê£ÄÊµãÂà∞ÊïèÊÑüËØçËøáÊª§(1301)Ôºå‰∏çÂÜçÈáçËØï")
                    raise ContentFilterError("ÂÜÖÂÆπÂåÖÂê´ÊïèÊÑüËØçÔºåË¢´ËøáÊª§")
                raise Exception(f"APIË∞ÉÁî®Â§±Ë¥•: HTTP {response.status}")

    except ContentFilterError:
        raise
    except Exception as e:
        key_manager.record_failure(selected_key, str(e))
        raise


# ============================================================
# Êï∞ÊçÆÂ∫ìÊìç‰Ωú
# ============================================================
async def get_pending_reviews(pool: aiomysql.Pool) -> List[ReviewTask]:
    """Ëé∑ÂèñÊâÄÊúâÂæÖÂ§ÑÁêÜÁöÑËØÑËÆ∫"""
    tasks = []

    async with pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cursor:
            # Êü•ËØ¢ÁæéÂõ¢Ë°®ÔºàÊúâproduct_nameÔºâ
            meituan_sql = """
                SELECT id, shop_id, shop_name, star_display, content, product_name
                FROM review_detail_meituan
                WHERE shop_reply = 'ÊöÇÊó†ÂõûÂ§ç' AND ai_gen IS NULL
            """
            await cursor.execute(meituan_sql)
            meituan_rows = await cursor.fetchall()

            for row in meituan_rows:
                tasks.append(ReviewTask(
                    table_name="review_detail_meituan",
                    id=row['id'],
                    shop_id=str(row['shop_id']) if row.get('shop_id') else "",
                    shop_name=row['shop_name'] or "Êú™Áü•Â∫óÈì∫",
                    star=int(row['star_display']) if row.get('star_display') else 5,
                    content=row['content'] if row['content'] else "Êó†",
                    product_name=row['product_name'] if row['product_name'] else "Êó†"
                ))

            logger.info(f"üìã ÁæéÂõ¢Ë°®ÂæÖÂ§ÑÁêÜ: {len(meituan_rows)} Êù°")

            # Êü•ËØ¢Â§ß‰ºóÁÇπËØÑË°®ÔºàÊó†product_nameÔºâ
            dianping_sql = """
                SELECT id, shop_id, shop_name, star_display, content
                FROM review_detail_dianping
                WHERE shop_reply = 'ÊöÇÊó†ÂõûÂ§ç' AND ai_gen IS NULL
            """
            await cursor.execute(dianping_sql)
            dianping_rows = await cursor.fetchall()

            for row in dianping_rows:
                tasks.append(ReviewTask(
                    table_name="review_detail_dianping",
                    id=row['id'],
                    shop_id=str(row['shop_id']) if row.get('shop_id') else "",
                    shop_name=row['shop_name'] or "Êú™Áü•Â∫óÈì∫",
                    star=int(row['star_display']) if row.get('star_display') else 5,
                    content=row['content'] if row['content'] else "Êó†",
                    product_name="Êó†"  # ÁÇπËØÑË°®Ê≤°ÊúâÂõ¢Ë¥≠‰ø°ÊÅØ
                ))

            logger.info(f"üìã ÁÇπËØÑË°®ÂæÖÂ§ÑÁêÜ: {len(dianping_rows)} Êù°")

    logger.info(f"üìã ÊÄªËÆ°ÂæÖÂ§ÑÁêÜ: {len(tasks)} Êù°")
    return tasks


async def update_ai_reply(pool: aiomysql.Pool, table_name: str, record_id: int, ai_reply: str) -> bool:
    """Êõ¥Êñ∞AIÂõûÂ§çÂà∞Êï∞ÊçÆÂ∫ì"""
    try:
        async with pool.acquire() as conn:
            async with conn.cursor() as cursor:
                sql = f"UPDATE {table_name} SET ai_gen = %s WHERE id = %s"
                await cursor.execute(sql, (ai_reply, record_id))
                await conn.commit()
                return True
    except Exception as e:
        logger.error(f"‚ùå Êõ¥Êñ∞Êï∞ÊçÆÂ∫ìÂ§±Ë¥• [{table_name}][{record_id}]: {e}")
        return False


async def get_review_ending(pool: aiomysql.Pool, shop_id: str) -> Optional[str]:
    """Ê†πÊçÆÈó®Â∫óIDÊü•ËØ¢ËØÑ‰ª∑ÁªìÂ∞æÊñáÊ°à"""
    if not shop_id:
        return None
    try:
        async with pool.acquire() as conn:
            async with conn.cursor(aiomysql.DictCursor) as cursor:
                sql = "SELECT review_ending FROM store_strategy_config WHERE store_id = %s"
                await cursor.execute(sql, (shop_id,))
                row = await cursor.fetchone()
                if row and row.get('review_ending'):
                    return row['review_ending']
                return None
    except Exception as e:
        logger.error(f"‚ùå Êü•ËØ¢ËØÑ‰ª∑ÁªìÂ∞æÂ§±Ë¥• [shop_id={shop_id}]: {e}")
        return None


# ============================================================
# ‰ªªÂä°Â§ÑÁêÜ
# ============================================================
async def process_single_task(
        task: ReviewTask,
        session_manager: SessionManager,
        pool: aiomysql.Pool,
        semaphore: asyncio.Semaphore
) -> Dict[str, Any]:
    """Â§ÑÁêÜÂçï‰∏™ËØÑËÆ∫‰ªªÂä°"""
    async with semaphore:
        task_id = f"[{task.table_name}][{task.id}]"

        try:
            # ÊûÑÂª∫ÊèêÁ§∫ËØç
            prompt = PROMPT_TEMPLATE.format(
                shop_name=task.shop_name,
                star=task.star,
                content=task.content,
                product_name=task.product_name
            )

            # Ë∞ÉÁî®AI
            logger.info(f"ü§ñ Â§ÑÁêÜ‰∏≠ {task_id} - {task.shop_name[:20]}...")
            ai_reply = await call_zhipuai(
                session_manager=session_manager,
                prompt=prompt,
                system_prompt=SYSTEM_PROMPT
            )

            # Êü•ËØ¢Âπ∂ÊãºÊé•ËØÑ‰ª∑ÁªìÂ∞æ
            review_ending = await get_review_ending(pool, task.shop_id)
            if review_ending:
                ai_reply = ai_reply.rstrip() + review_ending
                logger.info(f"üìé Â∑≤ÊãºÊé•ËØÑ‰ª∑ÁªìÂ∞æ {task_id}")

            # ÂÜôÂÖ•Êï∞ÊçÆÂ∫ì
            success = await update_ai_reply(pool, task.table_name, task.id, ai_reply)

            if success:
                logger.info(f"‚úÖ ÂÆåÊàê {task_id} - ÂõûÂ§çÈïøÂ∫¶: {len(ai_reply)}Â≠ó")
                return {"id": task.id, "table": task.table_name, "status": "success", "reply_length": len(ai_reply)}
            else:
                return {"id": task.id, "table": task.table_name, "status": "db_error"}

        except ContentFilterError:
            # ÊïèÊÑüËØçÈîôËØØÔºåÂÜôÂÖ•Âõ∫ÂÆöÊñáÊú¨
            logger.warning(f"‚ö†Ô∏è ÊïèÊÑüËØç {task_id} - ÂÜôÂÖ•Âõ∫ÂÆöÊèêÁ§∫")
            fixed_reply = "ÂåÖÂê´ÊïèÊÑüËØçÔºåÊó†Ê≥ïÁîüÊàê"
            success = await update_ai_reply(pool, task.table_name, task.id, fixed_reply)
            if success:
                return {"id": task.id, "table": task.table_name, "status": "filtered", "reply_length": len(fixed_reply)}
            else:
                return {"id": task.id, "table": task.table_name, "status": "db_error"}

        except Exception as e:
            logger.error(f"‚ùå Â§±Ë¥• {task_id}: {str(e)[:100]}")
            return {"id": task.id, "table": task.table_name, "status": "error", "error": str(e)[:200]}


async def main():
    """‰∏ªÂáΩÊï∞"""
    logger.info("=" * 60)
    logger.info("üöÄ AIËØÑËÆ∫ÂõûÂ§çÁîüÊàêÂô®ÂêØÂä®")
    logger.info("=" * 60)

    # ÂàõÂª∫Êï∞ÊçÆÂ∫ìËøûÊé•Ê±†
    pool = await aiomysql.create_pool(**DB_CONFIG, minsize=2, maxsize=10)
    session_manager = SessionManager()
    semaphore = asyncio.Semaphore(MAX_CONCURRENT)

    try:
        # Ëé∑ÂèñÂæÖÂ§ÑÁêÜ‰ªªÂä°
        tasks = await get_pending_reviews(pool)

        if not tasks:
            logger.info("‚úÖ Ê≤°ÊúâÂæÖÂ§ÑÁêÜÁöÑËØÑËÆ∫ÔºåÈÄÄÂá∫")
            return

        # Âπ∂ÂèëÂ§ÑÁêÜÊâÄÊúâ‰ªªÂä°
        start_time = time.time()

        results = await asyncio.gather(*[
            process_single_task(task, session_manager, pool, semaphore)
            for task in tasks
        ])

        # ÁªüËÆ°ÁªìÊûú
        elapsed = time.time() - start_time
        success_count = sum(1 for r in results if r['status'] == 'success')
        filtered_count = sum(1 for r in results if r['status'] == 'filtered')
        error_count = sum(1 for r in results if r['status'] not in ('success', 'filtered'))

        logger.info("=" * 60)
        logger.info(f"üèÅ Â§ÑÁêÜÂÆåÊàê!")
        logger.info(f"   ÊÄªËÆ°: {len(tasks)} Êù°")
        logger.info(f"   ÊàêÂäü: {success_count} Êù°")
        logger.info(f"   ÊïèÊÑüËØç: {filtered_count} Êù°")
        logger.info(f"   Â§±Ë¥•: {error_count} Êù°")
        logger.info(f"   ËÄóÊó∂: {elapsed:.1f} Áßí")
        logger.info("=" * 60)

        # ËæìÂá∫Â§±Ë¥•ËÆ∞ÂΩï
        if error_count > 0:
            logger.warning("‚ùå Â§±Ë¥•ËÆ∞ÂΩï:")
            for r in results:
                if r['status'] != 'success':
                    logger.warning(f"   - [{r['table']}][{r['id']}]: {r.get('error', r['status'])}")

    finally:
        await session_manager.close()
        pool.close()
        await pool.wait_closed()


if __name__ == "__main__":
    asyncio.run(main())
