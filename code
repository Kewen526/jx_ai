# -*- coding: utf-8 -*-
"""
AIËØÑËÆ∫ÂõûÂ§çÁîüÊàêÂô®
- ‰ªéMySQLÊï∞ÊçÆÂ∫ìËØªÂèñÊú™ÂõûÂ§çÁöÑÁæéÂõ¢/Â§ß‰ºóÁÇπËØÑËØÑËÆ∫
- Ë∞ÉÁî®Êô∫Ë∞±AIÁîüÊàêÂïÜÂÆ∂ÂõûÂ§ç
- Â∞ÜÁîüÊàêÁöÑÂõûÂ§çÂÜôÂõûÊï∞ÊçÆÂ∫ì
"""

import asyncio
import aiomysql
import aiohttp
import time
import threading
import logging
from typing import Optional, List, Dict, Any
from functools import wraps
from dataclasses import dataclass

# ============================================================
# Êó•ÂøóÈÖçÁΩÆ
# ============================================================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ============================================================
# Êï∞ÊçÆÂ∫ìÈÖçÁΩÆ
# ============================================================
DB_CONFIG = {
    "host": "8.146.210.145",
    "port": 3306,
    "user": "root",
    "password": "Kewen888@",
    "db": "jx_data_info",
    "charset": "utf8mb4",
    "autocommit": True
}

# Ë°®ÈÖçÁΩÆ
TABLES = {
    "meituan": {
        "name": "review_detail_meituan",
        "has_product": True
    },
    "dianping": {
        "name": "review_detail_dianping",
        "has_product": False
    }
}

# ============================================================
# APIÈÖçÁΩÆ
# ============================================================
ZHIPUAI_API_KEYS = [
    "f31eaff26ee04560836b1d3ab92eacc8.oyPI18DOuSKebrna",
    "69344382e19945a497697230f161c183.RAyvPnxU5docbnN7",
    "fa5a8e68c93e405fa402df81124af0f9.64aRePpnl0sAjJsq",
    "3f3b09e8aa524b069cdd2a589a76a261.OoeZfL1pzAWrKBEI",
    "65f085e030e446309959fcdbdf7bb528.9TpxtScWIEiDXgVp",
    "37a96354b4364d1199cd530198cd1506.SqjVbJcRyU2b31vE",
    "131a657523954446932045ed7e3cebc2.tsiLEwwbw2TC4ImB",
    "81b0ed0f1db74f278b7b7ccf7b77027c.8C18IDpwc0CkJJBO",
]

# Âπ∂ÂèëÊéßÂà∂
MAX_CONCURRENT = 3  # ÊúÄÂ§ßÂπ∂ÂèëÊï∞


# ============================================================
# Êï∞ÊçÆÊ®°Âûã
# ============================================================
@dataclass
class ReviewTask:
    """ËØÑËÆ∫‰ªªÂä°"""
    table_name: str
    id: int
    shop_name: str
    star: int
    content: str
    product_name: str


# ============================================================
# APIÂØÜÈí•ÁÆ°ÁêÜÂô®
# ============================================================
class APIKeyManager:
    """APIÂØÜÈí•ÁÆ°ÁêÜÂô® - Â§ÑÁêÜÈªëÂêçÂçïÂíåËΩÆÊç¢"""

    def __init__(self, blacklist_duration: int = 180):
        self.blacklist_duration = blacklist_duration
        self.blacklisted_keys = {}
        self.last_used_index = -1
        self.lock = threading.RLock()

    def add_to_blacklist(self, api_key: str, reason: str = "ÈôêÊµÅ"):
        with self.lock:
            end_time = time.time() + self.blacklist_duration
            self.blacklisted_keys[api_key] = end_time
            logger.warning(f"‚ö†Ô∏è ÂØÜÈí•Âä†ÂÖ•ÈªëÂêçÂçï({reason}): ...{api_key[-8:]} ({self.blacklist_duration}Áßí)")

    def is_blacklisted(self, api_key: str) -> bool:
        with self.lock:
            if api_key not in self.blacklisted_keys:
                return False
            current_time = time.time()
            if current_time >= self.blacklisted_keys[api_key]:
                del self.blacklisted_keys[api_key]
                logger.info(f"‚úÖ ÂØÜÈí•ÈªëÂêçÂçïËøáÊúüÊÅ¢Â§ç: ...{api_key[-8:]}")
                return False
            return True

    def get_next_available_key(self, all_keys: List[str]) -> Optional[str]:
        with self.lock:
            if not all_keys:
                return None
            self._cleanup_expired()
            available_keys = [key for key in all_keys if not self.is_blacklisted(key)]
            if not available_keys:
                logger.error(f"‚ùå ÊâÄÊúâ {len(all_keys)} ‰∏™ÂØÜÈí•ÈÉΩÂú®ÈªëÂêçÂçï‰∏≠")
                return None
            self.last_used_index = (self.last_used_index + 1) % len(available_keys)
            selected_key = available_keys[self.last_used_index]
            return selected_key

    def _cleanup_expired(self):
        current_time = time.time()
        expired = [k for k, t in self.blacklisted_keys.items() if current_time >= t]
        for key in expired:
            del self.blacklisted_keys[key]

    def record_success(self, api_key: str):
        pass  # ÈùôÈªòÊàêÂäü

    def record_failure(self, api_key: str, error_msg: str):
        error_lower = error_msg.lower()
        is_rate_limit = any(keyword in error_lower for keyword in [
            'rate limit', 'too many requests', '429', 'quota exceeded',
            '1302', 'Âπ∂ÂèëÊï∞ËøáÈ´ò', 'concurrent', 'ÈôêÊµÅ', 'ËØ∑Ê±ÇËøá‰∫éÈ¢ëÁπÅ'
        ])
        if is_rate_limit:
            self.add_to_blacklist(api_key, "ÈôêÊµÅ")
        else:
            logger.warning(f"‚ö†Ô∏è ÂØÜÈí•Ë∞ÉÁî®Â§±Ë¥•: ...{api_key[-8:]}, ÈîôËØØ: {error_msg[:100]}")


# ÂÖ®Â±ÄÂØÜÈí•ÁÆ°ÁêÜÂô®
key_manager = APIKeyManager(blacklist_duration=180)


# ============================================================
# ÊåáÊï∞ÈÄÄÈÅøÈáçËØïË£ÖÈ•∞Âô®
# ============================================================
def exponential_backoff_retry(max_retries: int = 10, base_wait: float = 2, max_wait: float = 60):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    result = await func(*args, **kwargs)
                    if isinstance(result, str) and 'Â§±Ë¥•' in result:
                        raise Exception(f"ËøîÂõûÂ§±Ë¥•ÁªìÊûú: {result}")
                    return result
                except Exception as e:
                    attempt_num = attempt + 1
                    logger.error(f"‚ùå Á¨¨{attempt_num}/{max_retries}Ê¨°Â∞ùËØïÂ§±Ë¥•: {str(e)[:200]}")
                    if attempt == max_retries - 1:
                        raise Exception(f"ÈáçËØï{max_retries}Ê¨°Âêé‰ªçÂ§±Ë¥•: {str(e)}")
                    wait_time = min(base_wait * (2 ** attempt), max_wait)
                    logger.warning(f"‚è≥ Á≠âÂæÖ{wait_time}ÁßíÂêéËøõË°åÁ¨¨{attempt_num + 1}Ê¨°ÈáçËØï...")
                    await asyncio.sleep(wait_time)
            raise Exception(f"ÈáçËØï{max_retries}Ê¨°Âêé‰ªçÂ§±Ë¥•")
        return wrapper
    return decorator


# ============================================================
# SessionÁÆ°ÁêÜÂô®
# ============================================================
class SessionManager:
    def __init__(self):
        self._session = None
        self._lock = asyncio.Lock()

    async def get_session(self) -> aiohttp.ClientSession:
        async with self._lock:
            if self._session is None or self._session.closed:
                timeout = aiohttp.ClientTimeout(total=120, connect=15)
                connector = aiohttp.TCPConnector(limit=20, limit_per_host=10)
                self._session = aiohttp.ClientSession(connector=connector, timeout=timeout)
            return self._session

    async def close(self):
        async with self._lock:
            if self._session and not self._session.closed:
                await self._session.close()


# ============================================================
# ÊèêÁ§∫ËØçÊ®°Êùø
# ============================================================
SYSTEM_PROMPT = "‰Ω†ÊòØ‰∏Ä‰Ωç‰∏ì‰∏öÁöÑÁæéÂõ¢/Â§ß‰ºóÁÇπËØÑÂïÜÂÆ∂ËØÑËÆ∫ÂõûÂ§çÂä©ÊâãÔºåË¥üË¥£‰∏∫SPA/Ë∂≥ÈÅì/ÂÖªÁîüÂ∫óÈì∫ÁîüÊàêÊ∏©È¶®„ÄÅ‰∏ì‰∏öÁöÑÂÆ¢Êà∑ËØÑËÆ∫ÂõûÂ§ç"

PROMPT_TEMPLATE = """
‰Ω†ÊòØ‰∏Ä‰Ωç‰∏ì‰∏öÁöÑÂïÜÂÆ∂ËØÑËÆ∫ÂõûÂ§çÂä©ÊâãÔºåË¥üË¥£‰∏∫SPA/Ë∂≥ÈÅì/ÂÖªÁîüÂ∫óÈì∫ÁîüÊàêÊ∏©È¶®„ÄÅ‰∏ì‰∏öÁöÑÂÆ¢Êà∑ËØÑËÆ∫ÂõûÂ§ç„ÄÇ

## ËæìÂÖ•‰ø°ÊÅØ
- Â∫óÈì∫ÂêçÁß∞Ôºö{shop_name}
- ËØÑËÆ∫ÊòüÁ∫ßÔºö{star}Ôºà1-5ÂàÜÔºå1-3‰∏∫‰∏≠Â∑ÆËØÑÔºå4-5‰∏∫Â•ΩËØÑÔºâ
- ÂÆ¢Êà∑ËØÑËÆ∫ÂÜÖÂÆπÔºö{content}ÔºàÂèØËÉΩ‰∏∫"Êó†"Ë°®Á§∫ÂÆ¢Êà∑Êú™ÂÜôËØÑËÆ∫ÊñáÂ≠óÔºâ
- ÂÆ¢Êà∑Ë¥≠‰π∞ÁöÑÂõ¢Ë¥≠Ôºö{product_name}ÔºàÂèØËÉΩ‰∏∫"Êó†"Ë°®Á§∫Êú™Ë¥≠‰π∞Âõ¢Ë¥≠Ôºâ

## ÂõûÂ§çËßÑÂàô

### 1. Ê†πÊçÆÊòüÁ∫ßË∞ÉÊï¥ËØ≠Ê∞î
- **Â•ΩËØÑÔºà4-5ÂàÜÔºâ**ÔºöÁÉ≠ÊÉÖÊÑüË∞¢ÔºåË°®ËææÊ¨£ÂñúÔºåËÇØÂÆöÂÆ¢Êà∑ÁöÑÈÄâÊã©
- **‰∏≠Â∑ÆËØÑÔºà1-3ÂàÜÔºâ**ÔºöÁúüËØöËá¥Ê≠âÔºåË°®ËææÈáçËßÜÔºåÊâøËØ∫ÊîπËøõ

### 2. Ê†πÊçÆËØÑËÆ∫ÂÜÖÂÆπ‰∏™ÊÄßÂåñÂõûÂ§ç
- Â¶ÇÊûúÂÆ¢Êà∑ÊèêÂà∞‰∫Ü**ÊäÄÂ∏àÁºñÂè∑**ÔºàÂ¶Ç"11Âè∑"„ÄÅ"88Âè∑"ÔºâÔºåÂú®ÂõûÂ§ç‰∏≠ÊèêÂèäËØ•ÊäÄÂ∏àÂπ∂Áªô‰∫àËÇØÂÆö
- Â¶ÇÊûúÂÆ¢Êà∑ÊèêÂà∞‰∫Ü**ÂÖ∑‰Ωì‰ΩìÈ™å**ÔºàÂ¶Ç"ÊâãÊ≥ïÂ•Ω"„ÄÅ"ÁéØÂ¢ÉÂπ≤ÂáÄ"ÔºâÔºåÂú®ÂõûÂ§ç‰∏≠ÂëºÂ∫îËøô‰∫õÂÜÖÂÆπ
- Â¶ÇÊûúÂÆ¢Êà∑ËØÑËÆ∫‰∏∫"Êó†"Ôºå‰ΩøÁî®ÈÄöÁî®ÁöÑÊÑüË∞¢/Ëá¥Ê≠âËØùÊúØ

### 3. Ê†πÊçÆÂõ¢Ë¥≠ÊÉÖÂÜµË∞ÉÊï¥ÂõûÂ§ç
- Â¶ÇÊûúÂÆ¢Êà∑**Ë¥≠‰π∞‰∫ÜÂõ¢Ë¥≠**ÔºåÂèØÂú®ÂõûÂ§ç‰∏≠ÊèêÂèäÔºö"ÊÑüË∞¢ÊÇ®ÈÄâË¥≠Êàë‰ª¨ÁöÑ{product_name}È°πÁõÆ"
- Â¶ÇÊûúÂÆ¢Êà∑**Êú™Ë¥≠‰π∞Âõ¢Ë¥≠**Ôºå‰∏çÈúÄË¶ÅÊèêÂèäÂõ¢Ë¥≠Áõ∏ÂÖ≥ÂÜÖÂÆπ

### 4. ÂõûÂ§çÁªìÊûÑ
**Â•ΩËØÑÂõûÂ§çÁªìÊûÑÔºö**
1. Áß∞Âëº + ÊÑüË∞¢ËØ≠
2. ÂõûÂ∫îËØÑËÆ∫‰∏≠ÁöÑÂÖ∑‰ΩìÂÜÖÂÆπÔºàÂ¶ÇÊúâÔºâ
3. Â∫óÈì∫ÁöÑÊúçÂä°ÁêÜÂøµ/ÊâøËØ∫
4. ÊúüÂæÖÂÜçÊ¨°ÂÖâ‰∏¥
5. Êé®ËçêÂÖ∂‰ªñÈ°πÁõÆÔºàÂ¶ÇÊúâÔºâ

**‰∏≠Â∑ÆËØÑÂõûÂ§çÁªìÊûÑÔºö**
1. Áß∞Âëº + Ëá¥Ê≠âËØ≠
2. Ë°®ËææÂØπÂÆ¢Êà∑ÂèçÈ¶àÁöÑÈáçËßÜ
3. ÊâøËØ∫ÊîπËøõ
4. ÊÑüË∞¢ÂèçÈ¶à + ÊúüÂæÖÁªô‰∫àÂÜçÊ¨°Êú∫‰ºö

### 5. ËØ≠Ë®ÄÈ£éÊ†º
- ‰∫≤ÂàáÊ∏©ÊöñÔºåÈÅøÂÖçËøá‰∫éÂÆòÊñπ
- Áß∞ÂëºÂèØÁî®Ôºö‰∫≤Áà±ÁöÑÈ°æÂÆ¢„ÄÅÂ∞äÊï¨ÁöÑÂÆ¢ÂÆò„ÄÅ‰∫≤Áà±ÁöÑÂ∞èÂì•Âì•ÔºàÁî∑Â£´SPAÂ∫óÂèØÁî®Ôºâ
- ÂõûÂ§çÈïøÂ∫¶Ôºö100-200Â≠ó‰∏∫ÂÆú
- Ëá™ÁÑ∂ÊµÅÁïÖÔºåÈÅøÂÖçÁîüÁ°¨ÁöÑÊ®°ÊùøÊÑü

## ËæìÂá∫Ë¶ÅÊ±Ç
Áõ¥Êé•ËæìÂá∫ÂõûÂ§çÂÜÖÂÆπÔºåÊó†ÈúÄÂÖ∂‰ªñËØ¥Êòé„ÄÇ
"""


# ============================================================
# AIË∞ÉÁî®ÂáΩÊï∞
# ============================================================
@exponential_backoff_retry(max_retries=10, base_wait=2, max_wait=60)
async def call_zhipuai(
        session_manager: SessionManager,
        prompt: str,
        system_prompt: str = None,
        model: str = "glm-4-flash",
        temperature: float = 0.1,
        max_tokens: int = 4096
) -> str:
    """Ë∞ÉÁî®Êô∫Ë∞±AI"""
    selected_key = key_manager.get_next_available_key(ZHIPUAI_API_KEYS)

    if not selected_key:
        logger.warning("‚ö†Ô∏è ÊâÄÊúâÂØÜÈí•ÈÉΩÂú®ÈªëÂêçÂçï‰∏≠ÔºåÁ≠âÂæÖ30Áßí...")
        await asyncio.sleep(30)
        selected_key = key_manager.get_next_available_key(ZHIPUAI_API_KEYS)
        if not selected_key:
            raise Exception("ÊâÄÊúâÂØÜÈí•ÈÉΩ‰∏çÂèØÁî®")

    try:
        url = "https://open.bigmodel.cn/api/paas/v4/chat/completions"
        headers = {
            "Authorization": f"Bearer {selected_key}",
            "Content-Type": "application/json"
        }

        messages = []
        if system_prompt:
            messages.append({"role": "system", "content": system_prompt})
        messages.append({"role": "user", "content": prompt})

        payload = {
            "model": model,
            "messages": messages,
            "temperature": temperature,
            "max_tokens": max_tokens
        }

        session = await session_manager.get_session()

        async with session.post(url, headers=headers, json=payload, timeout=120) as response:
            if response.status == 200:
                result = await response.json()
                if 'choices' in result and len(result['choices']) > 0:
                    content = result['choices'][0]['message']['content']
                    key_manager.record_success(selected_key)
                    return content
                else:
                    raise Exception(f"ÂìçÂ∫îÊ†ºÂºèÈîôËØØ: {result}")
            else:
                response_text = await response.text()
                key_manager.record_failure(selected_key, f"HTTP {response.status}: {response_text}")
                raise Exception(f"APIË∞ÉÁî®Â§±Ë¥•: HTTP {response.status}")

    except Exception as e:
        key_manager.record_failure(selected_key, str(e))
        raise


# ============================================================
# Êï∞ÊçÆÂ∫ìÊìç‰Ωú
# ============================================================
async def get_pending_reviews(pool: aiomysql.Pool) -> List[ReviewTask]:
    """Ëé∑ÂèñÊâÄÊúâÂæÖÂ§ÑÁêÜÁöÑËØÑËÆ∫"""
    tasks = []

    async with pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cursor:
            # Êü•ËØ¢ÁæéÂõ¢Ë°®ÔºàÊúâproduct_nameÔºâ
            meituan_sql = """
                SELECT id, shop_name, star, content, product_name
                FROM review_detail_meituan
                WHERE shop_reply = 'ÊöÇÊó†ÂõûÂ§ç' AND ai_gen IS NULL
            """
            await cursor.execute(meituan_sql)
            meituan_rows = await cursor.fetchall()

            for row in meituan_rows:
                tasks.append(ReviewTask(
                    table_name="review_detail_meituan",
                    id=row['id'],
                    shop_name=row['shop_name'] or "Êú™Áü•Â∫óÈì∫",
                    star=row['star'] or 5,
                    content=row['content'] if row['content'] else "Êó†",
                    product_name=row['product_name'] if row['product_name'] else "Êó†"
                ))

            logger.info(f"üìã ÁæéÂõ¢Ë°®ÂæÖÂ§ÑÁêÜ: {len(meituan_rows)} Êù°")

            # Êü•ËØ¢Â§ß‰ºóÁÇπËØÑË°®ÔºàÊó†product_nameÔºâ
            dianping_sql = """
                SELECT id, shop_name, star, content
                FROM review_detail_dianping
                WHERE shop_reply = 'ÊöÇÊó†ÂõûÂ§ç' AND ai_gen IS NULL
            """
            await cursor.execute(dianping_sql)
            dianping_rows = await cursor.fetchall()

            for row in dianping_rows:
                tasks.append(ReviewTask(
                    table_name="review_detail_dianping",
                    id=row['id'],
                    shop_name=row['shop_name'] or "Êú™Áü•Â∫óÈì∫",
                    star=row['star'] or 5,
                    content=row['content'] if row['content'] else "Êó†",
                    product_name="Êó†"  # ÁÇπËØÑË°®Ê≤°ÊúâÂõ¢Ë¥≠‰ø°ÊÅØ
                ))

            logger.info(f"üìã ÁÇπËØÑË°®ÂæÖÂ§ÑÁêÜ: {len(dianping_rows)} Êù°")

    logger.info(f"üìã ÊÄªËÆ°ÂæÖÂ§ÑÁêÜ: {len(tasks)} Êù°")
    return tasks


async def update_ai_reply(pool: aiomysql.Pool, table_name: str, record_id: int, ai_reply: str) -> bool:
    """Êõ¥Êñ∞AIÂõûÂ§çÂà∞Êï∞ÊçÆÂ∫ì"""
    try:
        async with pool.acquire() as conn:
            async with conn.cursor() as cursor:
                sql = f"UPDATE {table_name} SET ai_gen = %s WHERE id = %s"
                await cursor.execute(sql, (ai_reply, record_id))
                await conn.commit()
                return True
    except Exception as e:
        logger.error(f"‚ùå Êõ¥Êñ∞Êï∞ÊçÆÂ∫ìÂ§±Ë¥• [{table_name}][{record_id}]: {e}")
        return False


# ============================================================
# ‰ªªÂä°Â§ÑÁêÜ
# ============================================================
async def process_single_task(
        task: ReviewTask,
        session_manager: SessionManager,
        pool: aiomysql.Pool,
        semaphore: asyncio.Semaphore
) -> Dict[str, Any]:
    """Â§ÑÁêÜÂçï‰∏™ËØÑËÆ∫‰ªªÂä°"""
    async with semaphore:
        task_id = f"[{task.table_name}][{task.id}]"

        try:
            # ÊûÑÂª∫ÊèêÁ§∫ËØç
            prompt = PROMPT_TEMPLATE.format(
                shop_name=task.shop_name,
                star=task.star,
                content=task.content,
                product_name=task.product_name
            )

            # Ë∞ÉÁî®AI
            logger.info(f"ü§ñ Â§ÑÁêÜ‰∏≠ {task_id} - {task.shop_name[:20]}...")
            ai_reply = await call_zhipuai(
                session_manager=session_manager,
                prompt=prompt,
                system_prompt=SYSTEM_PROMPT
            )

            # ÂÜôÂÖ•Êï∞ÊçÆÂ∫ì
            success = await update_ai_reply(pool, task.table_name, task.id, ai_reply)

            if success:
                logger.info(f"‚úÖ ÂÆåÊàê {task_id} - ÂõûÂ§çÈïøÂ∫¶: {len(ai_reply)}Â≠ó")
                return {"id": task.id, "table": task.table_name, "status": "success", "reply_length": len(ai_reply)}
            else:
                return {"id": task.id, "table": task.table_name, "status": "db_error"}

        except Exception as e:
            logger.error(f"‚ùå Â§±Ë¥• {task_id}: {str(e)[:100]}")
            return {"id": task.id, "table": task.table_name, "status": "error", "error": str(e)[:200]}


async def main():
    """‰∏ªÂáΩÊï∞"""
    logger.info("=" * 60)
    logger.info("üöÄ AIËØÑËÆ∫ÂõûÂ§çÁîüÊàêÂô®ÂêØÂä®")
    logger.info("=" * 60)

    # ÂàõÂª∫Êï∞ÊçÆÂ∫ìËøûÊé•Ê±†
    pool = await aiomysql.create_pool(**DB_CONFIG, minsize=2, maxsize=10)
    session_manager = SessionManager()
    semaphore = asyncio.Semaphore(MAX_CONCURRENT)

    try:
        # Ëé∑ÂèñÂæÖÂ§ÑÁêÜ‰ªªÂä°
        tasks = await get_pending_reviews(pool)

        if not tasks:
            logger.info("‚úÖ Ê≤°ÊúâÂæÖÂ§ÑÁêÜÁöÑËØÑËÆ∫ÔºåÈÄÄÂá∫")
            return

        # Âπ∂ÂèëÂ§ÑÁêÜÊâÄÊúâ‰ªªÂä°
        start_time = time.time()

        results = await asyncio.gather(*[
            process_single_task(task, session_manager, pool, semaphore)
            for task in tasks
        ])

        # ÁªüËÆ°ÁªìÊûú
        elapsed = time.time() - start_time
        success_count = sum(1 for r in results if r['status'] == 'success')
        error_count = sum(1 for r in results if r['status'] != 'success')

        logger.info("=" * 60)
        logger.info(f"üèÅ Â§ÑÁêÜÂÆåÊàê!")
        logger.info(f"   ÊÄªËÆ°: {len(tasks)} Êù°")
        logger.info(f"   ÊàêÂäü: {success_count} Êù°")
        logger.info(f"   Â§±Ë¥•: {error_count} Êù°")
        logger.info(f"   ËÄóÊó∂: {elapsed:.1f} Áßí")
        logger.info("=" * 60)

        # ËæìÂá∫Â§±Ë¥•ËÆ∞ÂΩï
        if error_count > 0:
            logger.warning("‚ùå Â§±Ë¥•ËÆ∞ÂΩï:")
            for r in results:
                if r['status'] != 'success':
                    logger.warning(f"   - [{r['table']}][{r['id']}]: {r.get('error', r['status'])}")

    finally:
        await session_manager.close()
        pool.close()
        await pool.wait_closed()


if __name__ == "__main__":
    asyncio.run(main())
